= NAB Serverless Demo
:imagesdir: images

[IMPORTANT]
.Setting up the Demo
====

Run the folloing commands in a shell
----
git clone https://github.com/hatmarch/cloud-native-workshop-v2m4-labs.git -b prior-to-serverless-convert
cd cloud-native-workshop-v2m4
export DEMO_HOME=$(pwd)

# ensure we have access to the stack that can build the app for .devcontainer
docker login registry.redhat.io
code .
----

* Make sure you have a user1-cloudnativeapps namespace
----
oc new-project user1-cloudnativeapps
----

* Subscribe to the AMQ Streams Operator in the user1-cloudnativeapps namespace

* Install the kafka queues and two topics

----
oc apply -f $DEMO_HOME/install/kafka/kafka.yaml
oc apply -f $DEMO_HOME/install/kafka/kafka-order-topic.yaml 
oc apply -f $DEMO_HOME/install/kafka/kafka-payment-topic.yaml 
----

Kafka is installed once you see the following pods
----
my-cluster-kafka-0                                    2/2     Running     0          94s
my-cluster-kafka-1                                    2/2     Running     0          94s
my-cluster-kafka-2                                    2/2     Running     0          94s
my-cluster-zookeeper-0                                2/2     Running     0          4m13s
my-cluster-zookeeper-1                                2/2     Running     0          4m13s
my-cluster-zookeeper-2                                2/2     Running     0          4m12s
----

Apply the template
----
oc apply -f $DEMO_HOME/install/cool-store-pre-serverless.yaml
----

Updates after template 
----
oc project user1-cloudnativeapps
$DEMO_HOME/install/template-fix.sh
----

Build Every Project

----
cd inventory-service/
mvn clean package -DskipTests
    * Deploy with:
oc start-build inventory --from-file target/*-runner.jar --follow
* Order Service
cd order-service
export MAVEN_OPTS="-Xmx1024M -Xss128M -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=1024M -XX:+CMSClassUnloadingEnabled"
mvn clean package -DskipTests
    * deploy with
oc start-build order --from-file target/*-runner.jar --follow
* Catalog service
cd catalog-service/
mvn clean package spring-boot:repackage -DskipTests
    * Deploy with
oc start-build catalog --from-file=target/catalog-1.0.0-SNAPSHOT.jar --follow
* Cart service
cd cart-service
export MAVEN_OPTS="-Xmx1024M -Xss128M -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=1024M -XX:+CMSClassUnloadingEnabled"
mvn clean package -DskipTests
    * Deploy with
oc start-build cart --from-file target/*-runner.jar --follow
* Payment service (initial)
cd payment-service
export MAVEN_OPTS="-Xmx1024M -Xss128M -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=1024M -XX:+CMSClassUnloadingEnabled"
mvn clean package -DskipTests
    * deploy with
oc start-build payment --from-file target/*-runner.jar --follow
* Coolstore: build with
cd coolstore-ui
npm install --save-dev nodeshift
npm run nodeshift
----

Install all required operators (see also Kamesh's guide link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-basics/0.7.x/01-setup.html#download-tutorial-sources[here])

----
oc adm new-project istio-system 
oc adm new-project knative-serving
oc adm new-project knative-eventing

oc apply -f "$DEMO_HOME/install/redhat-operators-csc.yaml" \
  -f "$DEMO_HOME/install/community-operators-csc.yaml"

oc -n openshift-marketplace get csc
----

A successful reconciliation should show an output like:

----
NAME                           STATUS      MESSAGE                                       AGE
community-operators-packages   Succeeded   The object has been successfully reconciled   62s
redhat-operators-packages      Succeeded   The object has been successfully reconciled   62s
----

Open a new terminal and start a watch on the command oc get csv -n openshift-operators. For further reference in the setup we will call this terminal as WATCH_WINDOW.

----
watch 'oc get csv -n openshift-operators -ocustom-columns-file=$DEMO_HOME/install/csv-columns.txt'
----

Subscribe to Service Mesh

----
oc apply -f "$DEMO_HOME/install/servicemesh/subscription.yaml"
----

A successful servicemesh subscription install should show the output in WATCH_WINDOW like:

----
NAME                                         VERSION               PHASE
elasticsearch-operator.4.1.20-201910102034   4.1.20-201910102034   Succeeded
jaeger-operator.v1.13.1                      1.13.1                Succeeded
kiali-operator.v1.0.6                        1.0.6                 Succeeded
servicemeshoperator.v1.0.1                   1.0.1                 Succeeded
----

The servicemesh operator needs to be copied to the istio-system project before we can create a ServiceMeshControlPlane and ServiceMeshMemberRoll custom resources, you can watch the status using the command:

----
watch 'oc get csv -n istio-system -ocustom-columns-file=$DEMO_HOME/install/csv-columns.txt'


----

Now start up the service mesh

----
oc create -f "$DEMO_HOME/install/servicemesh/smcp.yaml" && \
oc create -f "$DEMO_HOME/install/servicemesh/smmr.yaml"
----

It will take few minutes for the servicemesh components to be installed, you can watch the status using the command:

----
oc get pods -n istio-system -w
----

A successful servicemesh install should show the following pods:

----
NAME                                     READY   STATUS    RESTARTS   AGE
cluster-local-gateway-7795cc7956-mqmq7   1/1     Running   0          92s
istio-citadel-f88bdd688-c52z8            1/1     Running   0          2m58s
istio-galley-f8f96c6bf-x7f4k             1/1     Running   0          2m48s
istio-ingressgateway-65bf84457c-7rh5t    1/1     Running   0          92s
istio-pilot-7f57f8bb5b-cr2qr             1/1     Running   0          110s
----

WARNING: Installing Service Mesh and adding user1-cloudnativeapp to the service mesh might add a network policy that causes the routes to fail.  Delete this network policy to retore routes.

Install knative serving.  First subscribe

----
oc apply -f "$DEMO_HOME/install/knative-serving/subscription.yaml" 
oc get csv -n knative-serving -ocustom-columns-file=$DEMO_HOME/install/csv-columns.txt
----

Successful execution will look like this:

----
NAME                                        VERSION              PHASE
elasticsearch-operator.4.2.8-201911190952   4.2.8-201911190952   Succeeded
jaeger-operator.v1.13.1                     1.13.1               Succeeded
kiali-operator.v1.0.7                       1.0.7                Succeeded
serverless-operator.v1.2.0                  1.2.0                Succeeded
servicemeshoperator.v1.0.2                  1.0.2                Succeeded
----

Only when that's done can you configure knative serving

----
oc apply -f "$DEMO_HOME/install/knative-serving/cr.yaml" -n knative-serving

oc get pods -n knative-serving -w
----

A successful serverless install will show the following pods in knative-serving namespace:

----
NAME                                READY   STATUS    RESTARTS   AGE
activator-dfb5b7b67-hh5kh           1/1     Running   0          79s
autoscaler-85bb4898c5-5sssb         1/1     Running   0          77s
autoscaler-hpa-865b6d49b7-7sqns     1/1     Running   0          78s
controller-65c8dd48d6-5cl9v         1/1     Running   0          73s
networking-istio-7c9fb7dd4c-lsbdm   1/1     Running   0          73s
webhook-95969d4fc-t9d4v             1/1     Running   0          72s
----

Install Knative Eventing

----
oc apply -f "$DEMO_HOME/install/knative-eventing/subscription.yaml"
----

The knative-eventing operator needs to be copied to the knative-eventing project before we can create a KnativeEventing custom resource, you can watch the status using the command:

----
watch 'oc get csv -n knative-eventing -ocustom-columns-file=$DEMO_HOME/install/csv-columns.txt'
----

A successful knative eventing subscription install should show the output in WATCH_WINDOW like:

----
NAME                                         VERSION               PHASE
elasticsearch-operator.4.1.20-201910102034   4.1.20-201910102034   Succeeded
jaeger-operator.v1.13.1                      1.13.1                Succeeded
kiali-operator.v1.0.6                        1.0.6                 Succeeded
knative-eventing-operator.v0.8.0             0.8.0                 Succeeded
serverless-operator.v1.0.0                   1.0.0                 Succeeded
servicemeshoperator.v1.0.1                   1.0.1                 Succeeded
----

Finally, check that the pods in the knative-serving namespace look like this

----
$ oc get pods -n knative-eventing
NAME                                   READY   STATUS    RESTARTS   AGE
eventing-controller-5c7c649d4b-gf4v9   1/1     Running   0          7m11s
eventing-webhook-569c567bd5-wm5mk      1/1     Running   0          7m10s
imc-controller-7c9898558b-rkhtw        1/1     Running   0          7m4s
imc-dispatcher-cd5c98964-q94xd         1/1     Running   0          7m4s
sources-controller-5b86d684fb-252sd    1/1     Running   0          7m10s
----

====


== Context
image::coolstore-initial-ui.png[]

== Converting the Payment Service

Demonstrate the app working.  By going to the store.  You can find the URL like this:
----
oc get route coolstore-ui -n user1-cloudnativeapps
----

image:add-to-cart.png[]

From the cart, checkout and then enter credit card details (any 16-digit number beginning with 4 will work)

image:checkout.png[]

Now navigate to the orders page.  Notice that the order gets processed after about 5 seconds (you may need to refresh page to see this)

image:orders[]

=== Remove the old payment service

We need to remove our old microservice way of running the payment service.  For that we will delete build configs and existing deployments

IMPORTANT: Make sure you are logged into the console before starting down this path!

----
oc project user1-cloudnativeapps
oc delete bc/payment
oc delete dc/payment route/payment svc/payment
----

Navigate to the coolstore ui

Demonstrate that purchases can be made (as before), but orders are now not processed

image:no-payment-processing.png[]

=== Remove direct Knative integration code

Currently our Payment service directly binds to Kafka to listen for events. Now that we have Knative eventing integration, we no longer need this code. CMD+p to navigate to the *PaymentResource.java* file 

Delete (or comment out) the onMessage() method:

image:onMessage.png[]

And delete the configuration for the incoming stream. In *application.properties* , delete (or comment out) the following lines for the Incoming stream:

image:payment-app-properties.png[]

Explain that this is no longer necessary because instead the event will trigger the starting of a container with the event as the incoming context.

=== Recompile the payment service

[WARNING]
.Resource Requirements for Docker Quarkus Build
====
If you are running linux in a container, you need to make sure the docker daemon has enough memory assigned to it.  This configuration seemed to be enough to build the payment-service

image:docker-requirement.png[]
====


----
cd payment-service
export MAVEN_OPTS=" -Xmx1024M -Xss128M -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=1024M -XX:+CMSClassUnloadingEnabled"
mvn clean package -Pnative -DskipTests
----

While that's compiling, in another VSCode terminal, update our builder to be able to build native quarkus

----
oc new-build quay.io/quarkus/ubi-quarkus-native-binary-s2i:19.2.0 --binary --name=payment -l app=payment
----

Once the native maven build is done, we can start a build using our new configuration

----
cd $DEMO_HOME/payment-service
oc start-build payment --from-file target/*-runner --follow
----

=== Create a Knative service (Knative Serving)

In order to create the Knative service, we need to know which image needs to be spun up to handle, in this case, order events.  To find the image go to *Builds > Image Streams* on the left menu then input payment to show the payment imagestream. Click on payment imagestream:

image:find-image.png[]

In the Overview tab, copy the IMAGE REPOSITORY value shown 

image:image-repository.png[]

[TIP]
.You can use the command line to quickly get the image stream
====
----
oc get is payment -o jsonpath="{.status.dockerImageRepository}" -n user1-cloudnativeapps
----
====
Then open the *payment-service/knative/knative-serving-service.yaml* file and paste in that value

Then update and update the image: line with this value.

image:knative-service-edit.png[]

[TIP]
.To delete a knative service
====
Though knative services are reported from oc get svc and oc get rt, you cannot delete them in this way.  Instead you must delete them based on the distinct (knative) descriptor that they have

Here is a command to delete all services (exposed as routes) that have the name that includes 'payment'
----
oc delete services.serving.knative.dev $(oc get rt --no-headers | grep -i payment | awk '{print $1}')
----
====

==== Invoke the service

You can call the knative service that you just created if it is ready.  Your service is ready if you issue the following command and get the following output
----
$ oc get rt
NAME      URL                                                                           READY   REASON
payment   http://payment.user1-cloudnativeapps.apps.service-mesh-demo.openshifttc.com   True    
----

Call the service by using the following command
----
export SVC_URL=$(oc get rt payment -o template='{{ .status.url }}')
curl -i -H 'Content-Type: application/json' -d '{"foo": "bar"}' $SVC_URL
----

==== Service Autoscaling

NOTE: _The knative-serving attribute scale-to-zero-grace-period is a “dynamic parameter” i.e. any updates to this value are reflected immediately to all its consumers; while all other parameters are static parameters i.e. change to it need a restart of the autoscaler deployment of knative-serving namespace._

TODO: See link:https://knative.dev/docs/serving/samples/autoscale-go/index.html[here]

==== Service Revisions

TODO: See link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-basics/0.7.x/02-basic-fundas.html#deploying-new-revision[here]

==== Service Pinning

TODO: See link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-basics/0.7.x/02-basic-fundas.html#_service_pinned_to_first_revision[here]

=== Create Knative event to kickoff service (Knative Eventing)

Now we want to use events the order topic to be our *source* (see also link:https://knative.dev/docs/eventing/samples/kafka/source/index.html[here] for generic example) and use the payment service as our *sink*

First we need to install the Kafka knative event source as seen below.  In user1-cloudnativeapps go to *Operators > Operator Hub* to find it

image:kafka-event-operator.png[]

Then install the operator with the default values (e.g. across whole cluster)

Now we need to create an instance of kakfa eventing for our namespace.  To do this call

----
$ oc apply -f install/kafka-eventing/kafka-eventing.yaml 
knativeeventingkafka.eventing.knative.dev/knative-eventing-kafka created
----

Then wait until all the kafka pods are created.  Use the following watch command and look for output like this

----
$ watch oc get pods | grep -i ^kafka

----

Then use the yaml file to bind the kafka event source to the payment service sink

----
oc apply -f $DEMO_HOME/payment-service/knative/kafka-event-source.yaml 
----

Then check to make source the event source is running

----
$ oc get pods -l knative-eventing-source-name=kafka-source
----

Now we want to prepare some windows for our demo.

*Window 1*: Duplicate the tab where you're looking at the user1-cloudnativeapps project.  Then navigate to the *Workloads > Pods* and find the _my-cluster-kafka-0_ pod.  Go then to the Terminal tab.  From there, enter the command as follows (also in image) and click _Expand_ in the upper right corner

image:watch-orders.png[]

----
bin/kafka-console-consumer.sh --topic orders --bootstrap-server localhost:9092
----

*Window 2*: Duplicate the tab again and then switch to the *Developer Perspective*.  There will be a lot of pods, so you'll want to filter based on the "focus" application group.  Make sure the knative payment pod is featured prominently.  It should indicate zero pods

image:window2-setup.png[]


Then hit the coolstore-ui by *[SHIFT+OPTION] clicking* the launcher icon on the Developer Perspective (see previous) and moving the newly opened window to the right

Recommended arrangement is like this:

image:recommended-layout.png[]

[HINT]
.If you need to open the window another way...
====
You can find the URL by running this command in a terminal
----
oc get route -n user1-cloudnativeapps | grep coolstore-ui | awk '{print $2}'
----
====

Now puchase something and add it to the cart.  Then Checkout.

Upon checkout you should see the payment pod spinning up to consume the order

image:consuming-kafka-queue.png[]

You can then go to the *Orders* section of the site to show that the order was consumed.  When you return, the pod should be spun down (with a clear or black outline).

If you'd like to play more with spin up and spin down, you can click on the route badge on the topography view to show the pod spinning up and then spinning down.

You can also show how subsequent requests when pod is up continue to be serviced by that pod (subject to the max concurrency number setup in knative-eventing).

== TODO

* Make sure all services are properly annotatted with the "Focus" application group (will have to change yaml)
** Need to deal with connectors...see how these are done
** Can't find a way to setup the kafka source to put labels on the resultant pod

* Make sure the reset scripts work appropriately (with the option to keep all operators active)

* Update pre-req to include kafka eventing?

* Script for building all items

* install stern and kn on the .devcontainer

* Prove that the script runs on a brand new cluster